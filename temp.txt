import * as THREE from 'three';

const canvas = document.getElementById('neural-net');
if (!canvas) {
  console.warn('[NeuralNet] Canvas #neural-net not found.');
} else {
  // Renderer that uses the existing canvas
  const renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    alpha: true,          // transparent so backgrounds show
    premultipliedAlpha: true
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0); // fully transparent

  // Scene & camera
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    60,
    canvas.clientWidth / canvas.clientHeight,
    0.1,
    1000
  );
  camera.position.z = 60;

  // --- START OF MODIFICATION ---

  // Simple “neurons” (points) + connecting lines
  const NEURON_COUNT = 200;
  const positions = new Float32Array(NEURON_COUNT * 3);

  // Brain-like shape parameters (ellipsoid)
  const radiusX = 45;
  const radiusY = 28;
  const radiusZ = 35;

  // Generate points within an ellipsoid for a more organic, brain-like shape
  let i = 0;
  while (i < NEURON_COUNT) {
    // Generate a random point in the bounding box of the ellipsoid
    const x = (Math.random() - 0.5) * 2 * radiusX;
    const y = (Math.random() - 0.5) * 2 * radiusY;
    const z = (Math.random() - 0.5) * 2 * radiusZ;

    // Check if the point is inside the ellipsoid
    if ((x * x) / (radiusX * radiusX) + (y * y) / (radiusY * radiusY) + (z * z) / (radiusZ * radiusZ) < 1) {
      positions[i * 3 + 0] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
      i++;
    }
  }

  // --- END OF MODIFICATION ---


  // Points (neurons)
  const pointsGeom = new THREE.BufferGeometry();
  pointsGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const pointsMat = new THREE.PointsMaterial({
    size: 1.8,
    sizeAttenuation: true,
    transparent: true
  });
  const points = new THREE.Points(pointsGeom, pointsMat);
  scene.add(points);

  // Lines (connections) — lightweight dynamic mesh
  const maxConnections = 400;
  const linePositions = new Float32Array(maxConnections * 2 * 3);
  const lineGeom = new THREE.BufferGeometry();
  lineGeom.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
  lineGeom.setDrawRange(0, 0);
  const lineMat = new THREE.LineBasicMaterial({ transparent: true, opacity: 0.5 });
  const lines = new THREE.LineSegments(lineGeom, lineMat);
  scene.add(lines);

  // Resize
  function setSize() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    // Match canvas backing store to CSS size
    if (canvas.width !== w || canvas.height !== h) {
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
  }

  // Animate
  function animate(time) {
    setSize();

    // Rotate the cloud slowly
    scene.rotation.y = time * 0.0001;

    // Recompute a subset of connections each frame
    const pos = pointsGeom.attributes.position.array;
    let write = 0;
    const threshold = 18; // connection distance
    let count = 0;

    for (let i = 0; i < NEURON_COUNT && count < maxConnections; i++) {
      const ix = i * 3;
      for (let j = i + 1; j < NEURON_COUNT && count < maxConnections; j++) {
        const jx = j * 3;
        const dx = pos[ix] - pos[jx];
        const dy = pos[ix + 1] - pos[jx + 1];
        const dz = pos[ix + 2] - pos[jx + 2];
        const d2 = dx * dx + dy * dy + dz * dz;

        if (d2 < threshold * threshold) {
          linePositions[write++] = pos[ix];
          linePositions[write++] = pos[ix + 1];
          linePositions[write++] = pos[ix + 2];
          linePositions[write++] = pos[jx];
          linePositions[write++] = pos[jx + 1];
          linePositions[write++] = pos[jx + 2];
          count++;
        }
      }
    }
    lineGeom.setDrawRange(0, count * 2);
    lineGeom.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  requestAnimationFrame(animate);

  // Handle window resize (CSS size changes)
  window.addEventListener('resize', () => setSize());
}