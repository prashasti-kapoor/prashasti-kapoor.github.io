---
/* No frontmatter needed for this component */
---

<div id="background-container">
  <div id="sphere1" class="sphere"></div>
  <div id="sphere2" class="sphere"></div>
  <canvas id="neural-net" aria-hidden="true"></canvas>
</div>

<style>
  /* Fixed, full-screen background */
  #background-container {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    overflow: hidden;
    pointer-events: none; /* make the whole layer inert */
  }
  :global(main), :global(header), :global(footer) {
    position: relative;
    z-index: 1;
  }
  .sphere {
    position: absolute;
    border-radius: 50%;
    filter: blur(100px);
    animation: glow 20s infinite alternate;
    pointer-events: none;
  }
  #sphere1 {
    width: 80vmax; height: 80vmax;
    top: -40vmax; left: -40vmax;
    background: radial-gradient(circle, #ff00ff, #00ffff);
    opacity: 0.15;
  }
  #sphere2 {
    width: 70vmax; height: 70vmax;
    bottom: -35vmax; right: -35vmax;
    background: radial-gradient(circle, #ff7f00, #ffff00);
    opacity: 0.15; animation-delay: -10s;
  }
  @keyframes glow {
    0% { transform: scale(0.95); opacity: 0.10; }
    100% { transform: scale(1.05); opacity: 0.20; }
  }
  #neural-net {
    position: absolute; inset: 0;
    width: 100%; height: 100%;
    pointer-events: none; display: block;
  }
</style>

<script>
  // All your code from NeuralNet.js goes here
  import * as THREE from 'three';

  const canvas = document.getElementById('neural-net');
  if (!canvas) {
    console.warn('[NeuralNet] Canvas #neural-net not found.');
  } else {
    // Renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      premultipliedAlpha: true
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    // Scene & camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      60,
      canvas.clientWidth / canvas.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 60;

    // ---------- Helper: circular sprite texture for round points ----------
    function makeCircleTexture(size = 64) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      const r = size / 2;
      const g = ctx.createRadialGradient(r, r, r * 0.1, r, r, r);
      g.addColorStop(0, 'rgba(255,255,255,1)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(r, r, r, 0, Math.PI * 2);
      ctx.fill();
      const tex = new THREE.Texture(c);
      tex.needsUpdate = true;
      tex.flipY = false;
      return tex;
    }

    // --- NEURON INITIALIZATION ---
    const MAX_NEURONS = 250;
    let currentNeuronCount = 0;
    const positions = new Float32Array(MAX_NEURONS * 3);
    const pointsGeom = new THREE.BufferGeometry();
    pointsGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    pointsGeom.setDrawRange(0, 0);
    const pointsMat = new THREE.PointsMaterial({
      size: 1.8,
      sizeAttenuation: true,
      transparent: true,
      color: 0x00ffff,
      map: makeCircleTexture(),
      alphaTest: 0.05,
      depthWrite: false
    });
    const points = new THREE.Points(pointsGeom, pointsMat);
    scene.add(points);

    // Lines (connections)
    const maxConnections = 400;
    const linePositions = new Float32Array(maxConnections * 2 * 3);
    const lineGeom = new THREE.BufferGeometry();
    lineGeom.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
    lineGeom.setDrawRange(0, 0);
    const lineMat = new THREE.LineBasicMaterial({
      transparent: true,
      opacity: 0.45,
      color: 0x00ffff
    });
    const lines = new THREE.LineSegments(lineGeom, lineMat);
    scene.add(lines);

    // Resize
    function setSize() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      if (canvas.width !== w || canvas.height !== h) {
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
    }

    // Growth timing
    let lastNeuronAddTime = 0;
    const NEURON_ADD_INTERVAL = 40;

    function animate(time) {
      setSize();

      // Add neurons over time
      if (currentNeuronCount < MAX_NEURONS && time - lastNeuronAddTime > NEURON_ADD_INTERVAL) {
        lastNeuronAddTime = time;
        const idx = currentNeuronCount * 3;
        const arr = pointsGeom.attributes.position.array;
        arr[idx + 0] = (Math.random() - 0.5) * 120;
        arr[idx + 1] = (Math.random() - 0.5) * 70;
        arr[idx + 2] = (Math.random() - 0.5) * 80;
        currentNeuronCount++;
        pointsGeom.setDrawRange(0, currentNeuronCount);
        pointsGeom.attributes.position.needsUpdate = true;
      }

      scene.rotation.y = time * 0.0001;

      // Connection logic
      const pos = pointsGeom.attributes.position.array;
      const maxSegments = maxConnections;
      const threshold = 18;
      const maxPerNeuron = 3;
      const minPerNeuron = 1;
      const connCounts = new Uint8Array(currentNeuronCount);
      let write = 0;

      for (let i = 0; i < currentNeuronCount && write / 6 < maxSegments; i++) {
        if (connCounts[i] >= maxPerNeuron) continue;
        const ix = i * 3;
        for (let j = i + 1; j < currentNeuronCount && write / 6 < maxSegments; j++) {
          if (connCounts[i] >= maxPerNeuron) break;
          if (connCounts[j] >= maxPerNeuron) continue;
          const jx = j * 3;
          const dx = pos[ix] - pos[jx];
          const dy = pos[ix + 1] - pos[jx + 1];
          const dz = pos[ix + 2] - pos[jx + 2];
          const d2 = dx * dx + dy * dy + dz * dz;
          if (d2 < threshold * threshold) {
            linePositions[write++] = pos[ix];
            linePositions[write++] = pos[ix + 1];
            linePositions[write++] = pos[ix + 2];
            linePositions[write++] = pos[jx];
            linePositions[write++] = pos[jx + 1];
            linePositions[write++] = pos[jx + 2];
            connCounts[i] += 1;
            connCounts[j] += 1;
          }
        }
      }

      if (currentNeuronCount > 1) {
        for (let i = 0; i < currentNeuronCount && write / 6 < maxSegments; i++) {
          if (connCounts[i] >= minPerNeuron) continue;
          const ix = i * 3;
          let bestJ = -1;
          let bestD2 = Infinity;
          for (let j = 0; j < currentNeuronCount; j++) {
            if (i === j || connCounts[j] >= maxPerNeuron) continue;
            const jx = j * 3;
            const dx = pos[ix] - pos[jx];
            const dy = pos[ix + 1] - pos[jx + 1];
            const dz = pos[ix + 2] - pos[jx + 2];
            const d2 = dx * dx + dy * dy + dz * dz;
            if (d2 < bestD2) {
              bestD2 = d2;
              bestJ = j;
            }
          }
          if (bestJ !== -1) {
            const jx = bestJ * 3;
            linePositions[write++] = pos[ix];
            linePositions[write++] = pos[ix + 1];
            linePositions[write++] = pos[ix + 2];
            linePositions[write++] = pos[jx];
            linePositions[write++] = pos[jx + 1];
            linePositions[write++] = pos[jx + 2];
            connCounts[i] += 1;
            connCounts[bestJ] += 1;
          }
        }
      }
      
      const segmentsUsed = Math.floor(write / 6);
      lineGeom.setDrawRange(0, segmentsUsed * 2);
      lineGeom.attributes.position.needsUpdate = true;
      
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);

    window.addEventListener('resize', () => setSize());
  }
</script>